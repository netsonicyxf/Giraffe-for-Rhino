"""

Rhino Python Script Tutorial
Exercise 20

Import geometry into SOFiSTiK.
Strict layer structure is enforced:
	- all input geometry in a main 'input' layer
	- 1st children: 'nodes', 'beams', 'trusses', 'cables', 'springs'
	- 2nd children: '{group number} [{layer properties}]'
		e.g. '2 [ncs 2 ahin mymz]' 
		rules:
			white spaces allowed
			group number is mandatory
			layer properties may be omitted, including square brackets
	- 3rd children: '{properties}'
		e.g. 'ncs 3 ahin n'
		rules:
			no square brackets this time (layer names cannot start with square brackets)
			no group numbers
			
	each element may be named in '{element number} [{element properties}]' format

"""

import rhinoscriptsyntax as rs

import math

import string

def english_to_sofi(word):
	
	if (word == "nodes"):
		return "node"
	elif (word == "beams"):
		return "beam"
	elif (word == "trusses"):
		return "trus"
	elif (word == "cables"):
		return "cabl"
	elif (word == "springs"):
		return "spri"	


def is_taken_number(array, no, grp):
	
	for element in array:
	
		if (element.no == no):
		
			if (grp == -1):
				return True
				
			elif (grp == element.grp):
				return True	
		
	return False
	

class Layer:
	
	def __init__(self, name):
	
		self.name = name
		self.path = name.split("::")
		self.depth = len(self.path)
		self.last = self.path[self.depth - 1]


class Description:
	
	def __init__(self, s):
		
		self.no = -1
		self.prop = ""
		
		if (s != ""):
		
			i1 = s.find("[")
			i2 = s.find("]")
			
			if (i1 == -1 or i2 == -1):
			
				self.no = int(s.strip())
			
			else:
				
				no_string = s[0:(i1)].strip()
				
				self.no = (-1) if (no_string == "") else int(no_string)
				self.prop = s[(i1 + 1):(i2)]


class Node:
	
	def __init__(self, no, x, y, z, prop):
	
		self.no = no
		self.x = x
		self.y = y
		self.z = z
		self.prop = prop
		self.strict_naming = False
		
	def export(self):
	
		output = "node no " + str(self.no)
		output += " x " + str(self.x)
		output += " y " + str(self.y)
		output += " z " + str(self.z)
		output += " " + self.prop + "\n"
		
		return output	
		
		
	def distance_to(self, n):
	
		return ( (self.x - n.x) ** 2 + (self.y - n.y) ** 2 + (self.z - n.z) ** 2 ) ** 0.5


class Member:	

	def __init__(self, typ, grp, no, na, ne, prop):

		self.typ = typ
		self.grp = grp
		self.no = no
		self.na = na
		self.ne = ne
		self.prop = prop
		self.strict_naming = False	
		
		
	def export(self):
	
		output = self.typ + " no " + str(self.no)
		output += " na " + str(self.na)
		output += " ne " + str(self.ne)
		output += " " + self.prop + "\n"
		
		return output
		
		
class StructuralModel:

	def __init__(self, name):
		
		self.name = name
		
		# fan stands for first available number
		
		self.nodes = []
		self.fan_node = 1
		
		self.members = []
		self.fan_member = 1
		
		self.gdiv = 1000
		
		self.output_header = "$ generated by Giraffe for Rhino\n"
		self.output_header += "$   developed by Peter Szerzo\n"
		self.output_header += "+prog sofimsha\nhead " + self.name + "\n\nsyst init gdiv 1000\n"
		self.output_nodes = "\n\n!*!Label Nodes\n"
		self.output_members = "\n!*!Label Structural Members"
		self.output_footer = "\nend"
		self.output = ""
		
	def add_node(self, obj):
	
		attr = Description(rs.ObjectName(obj))
		coordinates = rs.PointCoordinates(obj)
		n = Node(attr.no, coordinates[0], coordinates[1], coordinates[2], attr.prop)
		
		if (n.no == -1):
		
			n.no = self.fan_node
			self.nodes.append(n)
		
		else:
						
			n.strict_naming = True
			self.nodes.append(n)
			
		while(is_taken_number(self.nodes, self.fan_node, -1)):
				
				self.fan_node += 1	
			
		
	def add_member(self, element, element_type, grp):
	
		attr = Description(rs.ObjectName(element))
	
		pa = rs.CurveStartPoint(element)
		pe = rs.CurveEndPoint(element)
		
		node_a = Node(-1, pa[0], pa[1], pa[2], "")
		node_e = Node(-1, pe[0], pe[1], pe[2], "")
		
		for node in self.nodes:
		
			if node_a.distance_to(node) < 0.001:
			
				node_a.no = node.no
				
			if node_e.distance_to(node) < 0.001:
			
				node_e.no = node.no	
				
		if (node_a.no == -1):
		
			node_a.no = self.fan_node
			self.add_node(pa)
			
		if (node_e.no == -1):
		
			node_e.no = self.fan_node
			self.add_node(pe)
		
		e = Member(element_type, grp, self.fan_member, node_a.no, node_e.no, "")
		
		self.members.append(e)
		self.output_members += e.export()
		
		while(is_taken_number(self.members, self.fan_member, grp)):
			self.fan_member += 1
		
				
	def export_nodes(self):

		for node in self.nodes:
			self.output_nodes += node.export()			
		self.output_nodes += "\n"	
		
		
	def export(self):
	
		return self.output_header + self.output_nodes + self.output_members + self.output_footer
		

def Main():
    
    sofi = StructuralModel("some structure")
    
    layer_names = rs.LayerNames()
    	
    for name in layer_names:
    
    	layer = Layer(name)
    
    	if (layer.path[0] == "input") and (layer.depth > 1):
    	
    		if (layer.path[1] == "nodes"):
    		
    			objects = rs.ObjectsByLayer(layer.name)
    			for obj in objects:
    				sofi.add_node(obj)
    	
    		elif (layer.depth > 2):
    	
	    		attr = Description(layer.last)
	    		group = attr.no
	    		prop = attr.prop
	    		
	    		element_type = english_to_sofi(layer.path[1])	
	    		
	    		if (layer.depth == 3):
	    		
	    			sofi.output_members += "\ngrp " + str(group) + "\n"
	    		
	    		if (prop != ""):
	    		
	    			sofi.output_members += "\n" + element_type + " prop " + prop + "\n"
	    	
	    		sofi.fan_member = 1
	    		while(is_taken_number(sofi.members, sofi.fan_member, group)):
	    			sofi.fan_member += 1
	    		
	    		objects = rs.ObjectsByLayer(layer.name)
	
	    		for obj in objects:
	    			
	    			sofi.add_member(obj, element_type, group)

    sofi.export_nodes()
    
    f = open("system.dat", "w")
    f.write(sofi.export())
    f.close()
    
Main()